// Package rand combines the security of a crypto random number generator with the speed of the predictable math random generator.
// The package keeps a pool of math generators, making it unlikely that two consecutive random numbers are generated by the same
// math generator.
// It also reseeds the math generators occassionally using a seed generated by a crypto generator.
package rand

import (
	cryptorand "crypto/rand"
	"encoding/binary"
	mathrand "math/rand"
	"sync"
	"sync/atomic"
)

var (
	pool sync.Pool
	ops  int32
)

func init() {
	// Prepopulate the pool
	for i := 0; i < 16; i++ {
		pool.Put(New())
	}
	pool.New = func() interface{} {
		return New()
	}
}

// New creates a new math random generator seeded by a crypto random number
func New() *mathrand.Rand {
	// Generate crypto random 64-bit seed
	b := make([]byte, 8)
	cryptorand.Read(b)
	n := binary.LittleEndian.Uint64(b)
	// Create a math random generator seeded with the seed
	s := mathrand.NewSource(int64(n))
	return mathrand.New(s)
}

// AlphaNum64 generates a random string of the specified length.
// The string will include only alphanumeric characters a-z, A-Z, 0-9
func AlphaNum64(length int) string {
	const letters = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01"
	bytes := make([]byte, length)
	r := pool.Get().(*mathrand.Rand)
	reseed(r)
	_, _ = r.Read(bytes)
	for i, b := range bytes {
		bytes[i] = letters[b&0x3F]
	}
	pool.Put(r)
	return string(bytes)
}

// AlphaNum32 generates a random string of the specified length.
// The string will include only uppercase letters and numbers A-V, 0-9
func AlphaNum32(length int) string {
	const letters = "0123456789ABCDEFGHIJKLMNOPQRSTUV"
	bytes := make([]byte, length)
	r := pool.Get().(*mathrand.Rand)
	reseed(r)
	_, _ = r.Read(bytes)
	for i, b := range bytes {
		bytes[i] = letters[b&0x1F]
	}
	pool.Put(r)
	return string(bytes)
}

// Intn generates a random number between 0 and n
func Intn(n int) int {
	r := pool.Get().(*mathrand.Rand)
	reseed(r)
	m := r.Intn(n)
	pool.Put(r)
	return m
}

// reseed the math random generator that was pulled from the pool once every 256 operations
func reseed(r *mathrand.Rand) {
	// Perform once every 256 operations
	o := atomic.AddInt32(&ops, 1)
	if o&0xFF != 0 {
		return
	}

	// Generate crypto random 64-bit seed
	b := make([]byte, 8)
	cryptorand.Read(b)
	n := binary.LittleEndian.Uint64(b)

	// Reseed the math random generator
	r.Seed(int64(n))
}
