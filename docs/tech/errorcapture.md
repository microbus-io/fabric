# Error Capture and Propagation

The philosophy of `Microbus` is that errors will happen, they will be unpredictable, they must never bring down the system, and they should be observable and easily debuggable. With this in mind, the framework is taking an opinionated approach to standardize the capturing and surfacing of errors. Note that "capturing" does not mean "handling". The latter cannot be generalized and is left up to the app developer (or user).

## Web Handler Returns Error

The standard `http.Handler` signature in Go does not return an `error` but rather leaves it to the developer to set the status code (often to `500`) and output an error message to the body of the response. This pattern results in repetitive error handling code that app developers may or may not conform to.

```go
func StandardHandler(w http.ResponseWriter, r *http.Request) {
	err := doSomething()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}

	err = doSomethingElse()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(err.Error()))
		return
	}
}
```

`Microbus` takes the approach of extending the default signature to include an `error` return value. The error is then processed by the framework in a wrapper function. With this pattern, the original code is simpler and more Go-like, and any errors are reported and surfaced in a consistent manner. For example, error may be printed to the body of the response, logged, and metered so that alerts can be triggered.

```go
func UserCodeHandler(w http.ResponseWriter, r *http.Request) error {
	err := doSomething()
	if err != nil {
		return err
	}

	err = doSomethingElse()
	if err != nil {
		return err
	}
	return nil
}

func WrapperOfHandler(w http.ResponseWriter, r *http.Request) {
	err := UserCodeHandler(w, r)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write(fmt.Sprintf("%+v", err))
		log.LogError(err)
		metrics.IncrementErrorCount(1)
		return
	}
}
```

## Catching Panics

Panics in Go that are not captured terminate the running process. With microservices that are expected to be always on, this is not a desirable outcome. To stop this from happening, the framework captures panics generated by user code and converts them to standard errors, which are then handled in a similar fashion. The wrapper function introduced earlier comes in handy here.

```go
func UserCodeHandler(w http.ResponseWriter, r *http.Request) error {
	panic("omg")
}

func WrapperOfHandler(w http.ResponseWriter, r *http.Request) {
	err := catchPanic(func() error {return UserCodeHandler(w, r)})
	if err != nil {
		...
	}
}
```

## Stack Trace

Errors in Go are as simple as an error message and do not include a stack trace. In distributed systems that are built by distributed teams, that makes it very difficult to identify the root cause. To address that, the framework is replacing the standard `errors` package with its [own implementation](../structure/errors.md) that is able to augment errors with stack locations. This is not entirely transparent and app developers must use `errors.Trace` to capture the stack location.

```go
import "github.com/microbus-io/errors"

func UserCodeHandler(w http.ResponseWriter, r *http.Request) error {
	err := doSomething()
	if err != nil {
		return errors.Trace(err)
	}
	return nil
}

func WrapperOfHandler(w http.ResponseWriter, r *http.Request) {
	err := catchPanic(func() error {return UserCodeHandler(w, r)})
	if err != nil {
		...
	}
}
```

With this in place, error messages look more like this, making it clear where the error originated from.

```
strconv.ParseInt: parsing "not-valid": invalid syntax

calculator.(*Service).Square
	/src/github.com/microbus-io/fabric/examples/calculator/service.go:75
connector.(*Connector).onRequest
	/src/github.com/microbus-io/fabric/connector/messaging.go:225
	calculator.example:443/square
connector.(*Connector).Publish
	/src/github.com/microbus-io/fabric/connector/messaging.go:94
	http.ingress.sys -> calculator.example
httpingress.(*Service).ServeHTTP
	/src/github.com/microbus-io/fabric/services/httpingress/service.go:124
```

## Propagation Over the Wire

Microservices run in different processes, often on different hardware or even geographies. When a client microservice calls a remote microservice and the latter returns an error, it would be a lot more developer-friendly if the client experienced the error as if it were local.

```go
func (s *Service) MyEndpoint(w http.ResponseWriter, r *http.Request) error {
	response, err := s.Publish(pub.GET("https://another.service/objects")) // Remote call
	if err != nil {
		return errors.Trace(err)
	}
}
```

The `Microbus` framework serializes any error generated by the remote microservice and reconstitutes it on the client side. Errors responses are identified by the special header `Microbus-Op-Code: Err` with the error serialized in the body as JSON, including its stack trace.

```
HTTP/1.1 500 Internal Server Error
Connection: close
Content-Type: application/json
Microbus-From-Host: beta.error.connector
Microbus-From-Id: k2slru4rof
Microbus-Msg-Id: bHh4yWGo
Microbus-Op-Code: Err

{
	"error": "it's really bad",
	"stack": [
		{
			"file": "/src/github.com/microbus-io/fabric/connector/messaging_test.go",
			"function": "connector.TestConnector_Error.func2",
			"line": 343
		},
		{
			"file": "/src/github.com/microbus-io/fabric/connector/messaging.go",
			"function": "connector.(*Connector).onRequest",
			"line": 225,
			"annotations": [
				"beta.error.connector:443/panic"
			]
		},
		{
			"file": "/src/github.com/microbus-io/fabric/connector/messaging.go",
			"function": "connector.(*Connector).onRequest",
			"line": 226
		}
	]
}
```

## Summary

By delegating errors to the framework, it is able to improve system stability, observability and developer experience.

* All errors are logged and metered
* Panics are captured
* Errors are propagated over the wire
* Stack traces help identify the root cause
