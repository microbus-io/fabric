# Metrics

Metrics within the `Microbus` framework relies on Prometheus and operates on a pull model. Prometheus pulls metrics from the metrics system microservice, which in turn pulls and aggregates metrics from all running microservices in the current deployment.

## Standard Metrics

All services by default expose a minimal set of metrics pertaining to the handling of incoming and outgoing requests. These include:

* The current service uptime in seconds
* The size of the response message to incoming requests
* The internal processing time of incoming requests
* Late reply message duration
* The total duration of outgoing requests
* Duration to acknowledgement
* Total log messages recorded

## Application Metrics

In addition, application developers are free to add arbitrary metrics that are pertinent to their application. These can be defined in `service.yaml` under the metrics section.

```yaml
# Metrics
#
# signature - Func(measure Type, label Type, label Type)
#   RequestDurationSeconds(dur time.Duration, method string, success bool)
#   MemoryUsageBytes(b int64)
#   DistanceMiles(miles float64, countryCode int)
#   RequestsCount(count int, domain string) - unit-less accumulating count
#   CPUSecondsTotal(dur time.Duration) - accumulating count with unit
#   See https://prometheus.io/docs/practices/naming/ for naming best practices
# description - Documentation
# kind - The kind of the metric, "histogram", "gauge" or "counter" (default)
# alias - The name of the metric to register with Prometheus
# buckets - Bucket boundaries for histograms [x,y,z,...]
metrics:
  - signature: Likes(num int, postId string)
    description: Likes counts the number of likes for a given post.
    kind: counter
    alias: myapp_message_post_number_of_likes
```

With regard to alias names, see [naming best practices](https://prometheus.io/docs/practices/naming/) for best practices.

The [collector types](https://prometheus.io/docs/concepts/metric_types/) supported are:

* Counter
* Histogram
* Guage

## Code Examples

```go
// This function would be generated by codegen based on the service.yaml example above. 
func (svc *Intermediate) IncrementLikes(num int, postId string) error {
	xnum := float64(num)
	xpostId := xpostId
	return svc.IncrementMetric("myapp_message_post_number_of_likes", xnum, xpostId)
}

func (svc *Intermediate) MyFunc() error {
  // ...

  // A like has been registered and we want this reflected in Prometheus.
  err := svc.IncrementLikes(1, postId)
  if err != nil {
    return errors.Trace(err)
  }
  return nil
}
```
