// Code generated by Microbus. DO NOT EDIT.

package intermediate

import (
	"context"
	"encoding/json"
	"net/http"
	"time"

	"github.com/microbus-io/fabric/connector"
	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/sub"

	"{{ .Package }}/{{ .PackageSuffix }}api"

	{{- if .Sinks }}
	{{ range $i, $s := .Sinks }}
	{{ .SourceSuffix }}api{{ Add $i 1 }} "{{ .Source }}/{{ .SourceSuffix }}api"
	{{- end}}{{end}}
)

var (
	_ context.Context
	_ *json.Decoder
	_ *http.Request
	_ time.Duration
	_ *errors.TracedError
	_ *httpx.ResponseRecorder
	_ sub.Option
	_ {{ .PackageSuffix }}api.Client
)

// Mock is a mockable version of the {{ .General.Host }} microservice,
// allowing functions, sinks and web handlers to be mocked.
type Mock struct {
	*connector.Connector

	{{- range (JoinHandlers .Functions .Sinks)}}
	Mock{{ .Name }} func({{ .In }}) ({{ .Out }})
	{{- end}}

	{{- range .Webs}}
	Mock{{ .Name }} func(w http.ResponseWriter, r *http.Request) (err error)
	{{- end}}
}

// NewMock creates a new mockable version of the microservice.
func NewMock(version int) *Mock {
	svc := &Mock{
		Connector: connector.New("{{ .General.Host }}"),
	}
	svc.SetVersion(version)
	svc.SetDescription(`{{ .General.Description }}`)
	svc.SetOnStartup(svc.doOnStartup)

	{{- if .Functions }}
	
	// Functions
	{{- range .Functions }}
	svc.Subscribe(`{{ .Path }}`, svc.do{{ .Name }} {{- if eq .Queue "none"}}, sub.NoQueue(){{end -}} )
	{{- end }}{{ end }}
	
	{{- if .Webs }}
	
	// Webs
	{{- range .Webs }}
	svc.Subscribe(`{{ .Path }}`, svc.do{{ .Name }} {{- if eq .Queue "none" }}, sub.NoQueue(){{ end -}} )
	{{- end }}{{ end }}

	{{- if .Sinks }}
	
	// Sinks
	{{- range $i, $s := .Sinks }}
	{{ .SourceSuffix }}api{{ Add $i 1 }}.NewHook(svc).
	{{- if .ForHost }}ForHost(`{{ .ForHost }}`).{{ end }}
	{{- .Event }}(svc.do{{ .Name }}
	{{- if eq .Queue "none"}}, sub.NoQueue(){{ end -}}
	)
	{{- end }}{{ end }}

	return svc
}

// doOnStartup makes sure that the mock is not executed in a non-dev environment.
func (svc *Mock) doOnStartup(ctx context.Context) (err error) {
	if svc.Deployment() != connector.LOCAL && svc.Deployment() != connector.TESTINGAPP {
		return errors.Newf("mocking disallowed in '%s' deployment", svc.Deployment())
	}
    return nil
}
{{/**/}}

{{- $shortPackage := .PackageSuffix }}
{{- range .Functions }}
// do{{ .Name }} handles marshaling for the {{ .Name }} function.
func (svc *Mock) do{{ .Name }}(w http.ResponseWriter, r *http.Request) error {
	if svc.Mock{{ .Name }} == nil {
		return errors.New("mocked endpoint '{{ .Name }}' not implemented")
	}
	var i {{ $shortPackage }}api.{{ .Name }}In
	var o {{ $shortPackage }}api.{{ .Name }}Out
	err := httpx.ParseRequestData(r, &i)
	if err!=nil {
		return errors.Trace(err)
	}
	{{ range .Signature.OutputArgs }}o.{{ CapitalizeIdentifier .Name }}, {{ end }}err = svc.Mock{{ .Name }}(
		r.Context(),
		{{- range .Signature.InputArgs }}
		i.{{ CapitalizeIdentifier .Name }},
		{{- end}}
	)
	if err != nil {
		return errors.Trace(err)
	}
	w.Header().Set("Content-Type", "application/json")
	{{- range .Signature.OutputArgs }}{{ if and (eq .Name "httpStatusCode") (eq .Type "int") }}
	w.WriteHeader(o.{{ CapitalizeIdentifier "httpStatusCode" }})
	{{- end}}{{- end}}
	err = json.NewEncoder(w).Encode(o)
	if err != nil {
		return errors.Trace(err)
	}
	return nil
}
{{ end}}

{{- range .Webs}}
// do{{ .Name }} handles the {{ .Name }} web handler.
func (svc *Mock) do{{ .Name }}(w http.ResponseWriter, r *http.Request) (err error) {
	if svc.Mock{{ .Name }} == nil {
		return errors.New("mocked endpoint '{{ .Name }}' not implemented")
	}
	err = svc.Mock{{ .Name }}(w, r)
    return errors.Trace(err)
}
{{ end }}

{{- range .Sinks }}
// do{{ .Name }} handles marshaling for the {{ .Name }} event sink.
func (svc *Mock) do{{ .Name }}({{ .In }}) ({{ .Out }}) {
	if svc.Mock{{ .Name }} == nil {
		err = errors.New("mocked endpoint '{{ .Name }}' not implemented")
		return
	}
	{{ range .Signature.OutputArgs }}{{ .Name }}, {{ end }}err = svc.Mock{{ .Name }}(ctx{{ range .Signature.InputArgs }}, {{ .Name }}{{ end }})
	err = errors.Trace(err)
	return
}
{{ end }}