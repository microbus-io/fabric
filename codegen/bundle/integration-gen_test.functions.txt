{{ range (JoinHandlers .Functions .Sinks) }}
{{- $t := .Signature.TestingT }}
// {{ .Name }}TestCase assists in asserting against the results of executing {{ .Name }}.
type {{ .Name }}TestCase struct {
	{{- range .Signature.OutputArgs }}
	{{ .Name }} {{ .Type }}
	{{- end }}
	err error

	Expect  func({{ $t }} *testing.T {{- range .Signature.OutputArgs }}, {{ .Name }} {{ .Type }}{{ end }}) *{{ .Name }}TestCase
	Error   func(t *testing.T, errContains string) *{{ .Name }}TestCase
	NoError func(t *testing.T) *{{ .Name }}TestCase
}

// Get returns the result of executing {{ .Name }}.
func (tc *{{ .Name }}TestCase) Get() ({{ .Out }}) {
	return {{ range .Signature.OutputArgs }}tc.{{ .Name }}, {{ end }}tc.err
}

// {{ .Name }} executes the function and returns a corresponding test case.
func {{ .Name }}({{ .In }}) *{{ .Name }}TestCase {
	tc := &{{ .Name }}TestCase{}
	tc.err = utils.CatchPanic(func() error {
		{{ range .Signature.OutputArgs }}tc.{{ .Name }}, {{ end }}tc.err = Svc.{{ .Name }}(ctx {{- range .Signature.InputArgs }}, {{ .Name }}{{ end }})
		return tc.err
	})
	tc.Expect = func({{ $t }} *testing.T {{- range .Signature.OutputArgs }}, {{ .Name }} {{ .Type }}{{ end }}) *{{ .Name }}TestCase {
		{{- if .Signature.OutputArgs }}
		if assert.NoError({{ $t }}, tc.err) {
			{{- range .Signature.OutputArgs }}
			{{- if eq .Type "time.Time" }}
			assert.True({{ $t }}, {{ .Name }}.Equal(tc.{{ .Name }}), "Expected %v, actual %v", {{ .Name }}, tc.{{ .Name }})
			{{- else }}
			assert.Equal({{ $t }}, {{ .Name }}, tc.{{ .Name }})
			{{- end}}{{ end }}
		}
		{{- else }}
		assert.NoError(t, tc.err)
		{{- end}}
		return tc
	}
	tc.Error = func({{ $t }} *testing.T, errContains string) *{{ .Name }}TestCase {
		if assert.Error({{ $t }}, tc.err) {
			assert.Contains({{ $t }}, tc.err.Error(), errContains)
		}
		return tc
	}
	tc.NoError = func({{ $t }} *testing.T) *{{ .Name }}TestCase {
		assert.NoError({{ $t }}, tc.err)
		return tc
	}
	return tc
}
{{ end }}