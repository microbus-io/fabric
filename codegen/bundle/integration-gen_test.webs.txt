{{ if .Webs }}
type WebOption func(req *pub.Request) error

// GET sets the method of the request.
func GET() WebOption {
	return WebOption(pub.Method("GET"))
}

// DELETE sets the method of the request.
func DELETE() WebOption {
	return WebOption(pub.Method("DELETE"))
}

// HEAD sets the method of the request.
func HEAD() WebOption {
	return WebOption(pub.Method("HEAD"))
}

// POST sets the method and body of the request.
func POST(body any) WebOption {
	return func(req *pub.Request) error {
		pub.Method("POST")(req)
		return pub.Body(body)(req)
	}
}

// PUT sets the method and body of the request.
func PUT(body any) WebOption {
	return func(req *pub.Request) error {
		pub.Method("PUT")(req)
		return pub.Body(body)(req)
	}
}

// PATCH sets the method and body of the request.
func PATCH(body any) WebOption {
	return func(req *pub.Request) error {
		pub.Method("PATCH")(req)
		return pub.Body(body)(req)
	}
}

// Method sets the method of the request.
func Method(method string) WebOption {
	return WebOption(pub.Method(method))
}

// Header sets the header of the request. It overwrites any previously set value.
func Header(name string, value string) WebOption {
	return WebOption(pub.Header(name, value))
}

// QueryArg adds the query argument to the request.
// The same argument may have multiple values.
func QueryArg(name string, value any) WebOption {
	return WebOption(pub.QueryArg(name, value))
}

// Query adds the escaped query arguments to the request.
// The same argument may have multiple values.
func Query(escapedQueryArgs string) WebOption {
	return WebOption(pub.Query(escapedQueryArgs))
}

// Body sets the body of the request.
// Arguments of type io.Reader, []byte and string are serialized in binary form.
// url.Values is serialized as form data.
// All other types are serialized as JSON.
func Body(body any) WebOption {
	return WebOption(pub.Body(body))
}

// ContentType sets the Content-Type header.
func ContentType(contentType string) WebOption {
	return WebOption(pub.ContentType(contentType))
}
{{ end }}

{{- $host := .General.Host }}{{ range .Webs }}
// {{ .Name }}TestCase assists in asserting against the results of executing {{ .Name }}.
type {{ .Name }}TestCase struct {
	testName string
	res *http.Response
	err error
}

// Name sets a name to the test case.
func (tc *{{ .Name }}TestCase) Name(testName string) *{{ .Name }}TestCase {
	tc.testName = testName
	return tc
}

// StatusOK asserts no error and a status code 200.
func (tc *{{ .Name }}TestCase) StatusOK(t *testing.T) *{{ .Name }}TestCase {
	t.Run(tc.testName, func(t *testing.T) {
		if assert.NoError(t, tc.err) {
			assert.Equal(t, tc.res.StatusCode, http.StatusOK)
		}
	})
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *{{ .Name }}TestCase) StatusCode(t *testing.T, statusCode int) *{{ .Name }}TestCase {
	t.Run(tc.testName, func(t *testing.T) {
		if assert.NoError(t, tc.err) {
			assert.Equal(t, tc.res.StatusCode, statusCode)
		}
	})
	return tc
}

// BodyContains asserts no error and that the response contains a string or byte array.
func (tc *{{ .Name }}TestCase) BodyContains(t *testing.T, bodyContains any) *{{ .Name }}TestCase {
	t.Run(tc.testName, func(t *testing.T) {
		if assert.NoError(t, tc.err) {
			body := tc.res.Body.(*httpx.BodyReader).Bytes()
			switch v := bodyContains.(type) {
			case []byte:
				assert.True(t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
			case string:
				assert.True(t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
			default:
				vv := fmt.Sprintf("%v", v)
				assert.True(t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
			}
		}
	})
	return tc
}

// BodyNotContains asserts no error and that the response does not contain a string or byte array.
func (tc *{{ .Name }}TestCase) BodyNotContains(t *testing.T, bodyNotContains any) *{{ .Name }}TestCase {
	t.Run(tc.testName, func(t *testing.T) {
		if assert.NoError(t, tc.err) {
			body := tc.res.Body.(*httpx.BodyReader).Bytes()
			switch v := bodyNotContains.(type) {
			case []byte:
				assert.False(t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
			case string:
				assert.False(t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
			default:
				vv := fmt.Sprintf("%v", v)
				assert.False(t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
			}
		}
	})
	return tc
}

// HeaderContains asserts no error and that the named header contains a string.
func (tc *{{ .Name }}TestCase) HeaderContains(t *testing.T, headerName string, valueContains string) *{{ .Name }}TestCase {
	t.Run(tc.testName, func(t *testing.T) {
		if assert.NoError(t, tc.err) {
			assert.True(t, strings.Contains(tc.res.Header.Get(headerName), valueContains), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), valueContains)
		}
	})
	return tc
}

// Error asserts an error.
func (tc *{{ .Name }}TestCase) Error(t *testing.T, errContains string) *{{ .Name }}TestCase {
	t.Run(tc.testName, func(t *testing.T) {
		if assert.Error(t, tc.err) {
			assert.Contains(t, tc.err.Error(), errContains)
		}
	})
	return tc
}

// NoError asserts no error.
func (tc *{{ .Name }}TestCase) NoError(t *testing.T) *{{ .Name }}TestCase {
	t.Run(tc.testName, func(t *testing.T) {
		assert.NoError(t, tc.err)
	})
	return tc
}

// Assert asserts using a provided function.
func (tc *{{ .Name }}TestCase) Assert(t *testing.T, asserter func(t *testing.T, res *http.Response, err error)) *{{ .Name }}TestCase {
	t.Run(tc.testName, func(t *testing.T) {
		asserter(t, tc.res, tc.err)
	})
	return tc
}

// Get returns the result of executing {{ .Name }}.
func (tc *{{ .Name }}TestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

// {{ .Name }} executes the web handler and returns a corresponding test case.
func {{ .Name }}(ctx context.Context, options ...WebOption) *{{ .Name }}TestCase {
	tc := &{{ .Name }}TestCase{}
	pubOptions := []pub.Option{
		pub.URL(httpx.JoinHostAndPath("{{ $host }}", `{{ .Path }}`)),
	}
	for _, opt := range options {
		pubOptions = append(pubOptions, pub.Option(opt))
	}
	req, err := pub.NewRequest(pubOptions...)
	if err != nil {
		panic(err)
	}
	httpReq, err := http.NewRequest(req.Method, req.URL, req.Body)
	if err != nil {
		panic(err)
	}
	for name, value := range req.Header {
		httpReq.Header[name] = value
	}
	r := httpReq.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.{{ .Name }}(w, r)
	})
	tc.res = w.Result()
	return tc
}
{{ end }}