{{ $host := .General.Host }}{{ range .Webs }}
// {{ .Name }}TestCase assists in asserting against the results of executing {{ .Name }}.
type {{ .Name }}TestCase struct {
	res *http.Response
	err error
	
	StatusOK        func(t *testing.T) *{{ .Name }}TestCase
	StatusCode      func(t *testing.T, statusCode int) *{{ .Name }}TestCase
	BodyContains    func(t *testing.T, bodyContains any) *{{ .Name }}TestCase
	BodyNotContains func(t *testing.T, bodyNotContains any) *{{ .Name }}TestCase
	Error           func(t *testing.T, errContains string) *{{ .Name }}TestCase
	NoError         func(t *testing.T) *{{ .Name }}TestCase
}

// Get returns the result of executing {{ .Name }}.
func (tc *{{ .Name }}TestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

// {{ .Name }} executes the web handler and returns a corresponding test case.
func {{ .Name }}(ctx context.Context, options ...WebOption) *{{ .Name }}TestCase {
	tc := &{{ .Name }}TestCase{}
	pubOptions := []pub.Option{
		pub.URL(httpx.JoinHostAndPath("{{ $host }}", `{{ .Path }}`)),
	}
	for _, opt := range options {
		pubOptions = append(pubOptions, pub.Option(opt))
	}
	req, err := pub.NewRequest(pubOptions...)
	if err != nil {
		panic(err)
	}
	httpReq, err := http.NewRequest(req.Method, req.URL, req.Body)
	if err != nil {
		panic(err)
	}
	for name, value := range req.Header {
		httpReq.Header[name] = value
	}
	r := httpReq.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.{{ .Name }}(w, r)
	})
	tc.res = w.Result()
	tc.StatusOK = func(t *testing.T) *{{ .Name }}TestCase {
		if assert.NoError(t, tc.err) {
			assert.Equal(t, tc.res.StatusCode, http.StatusOK)
		}
		return tc
	}
	tc.StatusCode = func(t *testing.T, statusCode int) *{{ .Name }}TestCase {
		if assert.NoError(t, tc.err) {
			assert.Equal(t, tc.res.StatusCode, statusCode)
		}
		return tc
	}
	tc.BodyContains = func(t *testing.T, bodyContains any) *{{ .Name }}TestCase {
		if assert.NoError(t, tc.err) {
			body := tc.res.Body.(*httpx.BodyReader).Bytes()
			switch v := bodyContains.(type) {
			case []byte:
				assert.True(t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
			case string:
				assert.True(t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
			default:
				vv := fmt.Sprintf("%v", v)
				assert.True(t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
			}
		}
		return tc
	}
	tc.BodyNotContains = func(t *testing.T, bodyNotContains any) *{{ .Name }}TestCase {
		if assert.NoError(t, tc.err) {
			body := tc.res.Body.(*httpx.BodyReader).Bytes()
			switch v := bodyNotContains.(type) {
			case []byte:
				assert.False(t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
			case string:
				assert.False(t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
			default:
				vv := fmt.Sprintf("%v", v)
				assert.False(t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
			}
		}
		return tc
	}
	tc.Error = func(t *testing.T, errContains string) *{{ .Name }}TestCase {
		if assert.Error(t, tc.err) {
			assert.Contains(t, tc.err.Error(), errContains)
		}
		return tc
	}
	tc.NoError = func(t *testing.T) *{{ .Name }}TestCase {
		assert.NoError(t, tc.err)
		return tc
	}
	return tc
}
{{ end }}