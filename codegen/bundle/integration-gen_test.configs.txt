{{ range .Configs }}{{ if .Callback }}
// OnChanged{{ .Name }}TestCase assists in asserting against the results of executing OnChanged{{ .Name }}.
type OnChanged{{ .Name }}TestCase struct {
	testName string
	err error
}

// Name sets a name to the test case.
func (tc *OnChanged{{ .Name }}TestCase) Name(testName string) *OnChanged{{ .Name }}TestCase {
	tc.testName = testName
	return tc
}

// Error asserts an error.
func (tc *OnChanged{{ .Name }}TestCase) Error(t *testing.T, errContains string) *OnChanged{{ .Name }}TestCase {
	t.Run(tc.testName, func(t *testing.T) {
		if assert.Error(t, tc.err) {
			assert.Contains(t, tc.err.Error(), errContains)
		}
	})
	return tc
}

// NoError asserts no error.
func (tc *OnChanged{{ .Name }}TestCase) NoError(t *testing.T) *OnChanged{{ .Name }}TestCase {
	t.Run(tc.testName, func(t *testing.T) {
		assert.NoError(t, tc.err)
	})
	return tc
}

// Assert asserts using a provided function.
func (tc *OnChanged{{ .Name }}TestCase) Assert(t *testing.T, asserter func(t *testing.T, err error)) *OnChanged{{ .Name }}TestCase {
	t.Run(tc.testName, func(t *testing.T) {
		asserter(t, tc.err)
	})
	return tc
}

// Get returns the result of executing {{ .Name }}.
func (tc *OnChanged{{ .Name }}TestCase) Get() (err error) {
	return tc.err
}

// OnChanged{{ .Name }} executes the on changed callback and returns a corresponding test case.
func OnChanged{{ .Name }}(ctx context.Context) *OnChanged{{ .Name }}TestCase {
	tc := &OnChanged{{ .Name }}TestCase{}
	tc.err = utils.CatchPanic(func () error {
		return Svc.OnChanged{{ .Name }}(ctx)
	})
	return tc
}
{{ end }}{{ end }}