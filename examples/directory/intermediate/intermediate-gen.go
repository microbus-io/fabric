// Code generated by Microbus. DO NOT EDIT.

/*
Package intermediate serves as the foundation of the directory.example microservice.

The directory microservice stores personal records in a MySQL database.
*/
package intermediate

import (
	"context"
	"embed"
	"encoding/json"
	"fmt"
	"net/http"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/microbus-io/fabric/cb"
	"github.com/microbus-io/fabric/cfg"
	"github.com/microbus-io/fabric/connector"
	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/log"
	"github.com/microbus-io/fabric/shardedsql"
	"github.com/microbus-io/fabric/sub"

	"github.com/microbus-io/fabric/examples/directory/resources"
	"github.com/microbus-io/fabric/examples/directory/directoryapi"
)

var (
	_ context.Context
	_ *embed.FS
	_ *json.Decoder
	_ fmt.Stringer
	_ *http.Request
	_ filepath.WalkFunc
	_ strconv.NumError
	_ strings.Reader
	_ time.Duration
	_ cb.Option
	_ cfg.Option
	_ *errors.TracedError
	_ *httpx.ResponseRecorder
	_ *log.Field
	_ *shardedsql.DB
	_ sub.Option
	_ directoryapi.Client
)

// ToDo defines the interface that the microservice must implement.
// The intermediate delegates handling to this interface.
type ToDo interface {
	OnStartup(ctx context.Context) (err error)
	OnShutdown(ctx context.Context) (err error)
	Create(ctx context.Context, person *directoryapi.Person) (created *directoryapi.Person, err error)
	Load(ctx context.Context, key directoryapi.PersonKey) (person *directoryapi.Person, ok bool, err error)
	Delete(ctx context.Context, key directoryapi.PersonKey) (err error)
	Update(ctx context.Context, person *directoryapi.Person) (err error)
	LoadByEmail(ctx context.Context, email string) (person *directoryapi.Person, ok bool, err error)
}

// Intermediate extends and customizes the generic base connector.
// Code generated microservices then extend the intermediate.
type Intermediate struct {
	*connector.Connector
	impl ToDo
	dbMySQL *shardedsql.DB
}

// NewService creates a new intermediate service.
func NewService(impl ToDo, version int) *Intermediate {
	svc := &Intermediate{
		Connector: connector.New("directory.example"),
		impl: impl,
	}
	svc.SetVersion(version)
	svc.SetDescription(`The directory microservice stores personal records in a MySQL database.`)

	// MySQL
	svc.SetOnStartup(svc.mysqlOnStartup)
	svc.SetOnShutdown(svc.mysqlOnShutdown)
	svc.DefineConfig(
		"MySQL",
		cfg.Description("MySQL is the connection string to the sharded MySQL database."),
		cfg.Secret(),
	)
	svc.SetOnConfigChanged(svc.mysqlOnConfigChanged)

	// Lifecycle
	svc.SetOnStartup(svc.impl.OnStartup)
	svc.SetOnShutdown(svc.impl.OnShutdown)
	
	// Functions
	svc.Subscribe(`:443/create`, svc.doCreate)
	svc.Subscribe(`:443/load`, svc.doLoad)
	svc.Subscribe(`:443/delete`, svc.doDelete)
	svc.Subscribe(`:443/update`, svc.doUpdate)
	svc.Subscribe(`:443/load-by-email`, svc.doLoadByEmail)

	return svc
}

// Resources is the in-memory file system of the embedded resources.
func (svc *Intermediate) Resources() embed.FS {
	return resources.FS
}

// doOnConfigChanged is called when the config of the microservice changes.
func (svc *Intermediate) doOnConfigChanged(ctx context.Context, changed func(string) bool) (err error) {
	return nil
}

// mysqlOnStartup opens the connection to the MySQL database and runs schema migrations.
func (svc *Intermediate) mysqlOnStartup(ctx context.Context) (err error) {
	if svc.dbMySQL != nil {
		svc.mysqlOnShutdown(ctx)
	}
	dataSource := svc.MySQL()
	if dataSource != "" {
		svc.dbMySQL, err = shardedsql.Open("mysql", dataSource)
		if err != nil {
			return errors.Trace(err)
		}
		svc.LogInfo(ctx, "Opened MySQL database", log.String("db", "MySQL"))

		migrations := shardedsql.NewStatementSequence(svc.HostName())
		scripts, _ := svc.Resources().ReadDir("mysql")
		for _, script := range scripts {
			if script.IsDir() || filepath.Ext(script.Name())!=".sql" {
				continue
			}
			number, err := strconv.Atoi(strings.TrimSuffix(script.Name(), ".sql"))
			if err != nil {
				continue
			}
			statement, _ := svc.Resources().ReadFile(filepath.Join("mysql", script.Name()))
			migrations.Insert(number, string(statement))
		}
		err = svc.dbMySQL.MigrateSchema(ctx, migrations)
		if err != nil {
			return errors.Trace(err)
		}
	}
	return nil
}

// mysqlOnStartup closes the connection to the MySQL database.
func (svc *Intermediate) mysqlOnShutdown(ctx context.Context) (err error) {
	if svc.dbMySQL != nil {
		svc.dbMySQL.Close()
		svc.dbMySQL = nil
		svc.LogInfo(ctx, "Closed MySQL database", log.String("db", "MySQL"))
	}
	return nil
}

// doOnConfigChanged reconnects to MySQL when the data source name changes.
func (svc *Intermediate) mysqlOnConfigChanged(ctx context.Context, changed func(string) bool) (err error) {
	if changed("MySQL") {
		err = svc.mysqlOnStartup(ctx)
		if err != nil {
			return errors.Trace(err)
		}
	}
	return nil
}

// MySQL is the data source name to the sharded MySQL database.
func (svc *Intermediate) MySQL() (dsn string) {
	return svc.Config("MySQL")
}

// MySQL initializes the MySQL config property of the microservice.
func MySQL(dsn string) (func(connector.Service) error) {
	return func(svc connector.Service) error {
		return svc.SetConfig("MySQL", dsn)
	}
}

// DBMySQL is the sharded MySQL database.
func (svc *Intermediate) DBMySQL() *shardedsql.DB {
	return svc.dbMySQL
}

// doCreate handles marshaling for the Create function.
func (svc *Intermediate) doCreate(w http.ResponseWriter, r *http.Request) error {
	var i directoryapi.CreateIn
	var o directoryapi.CreateOut
	err := httpx.ParseRequestData(r, &i)
	if err!=nil {
		return errors.Trace(err)
	}
	o.Created, err = svc.impl.Create(
		r.Context(),
		i.Person,
	)
	if err != nil {
		return errors.Trace(err)
	}
	w.Header().Set("Content-Type", "application/json")
	err = json.NewEncoder(w).Encode(o)
	if err != nil {
		return errors.Trace(err)
	}
	return nil
}

// doLoad handles marshaling for the Load function.
func (svc *Intermediate) doLoad(w http.ResponseWriter, r *http.Request) error {
	var i directoryapi.LoadIn
	var o directoryapi.LoadOut
	err := httpx.ParseRequestData(r, &i)
	if err!=nil {
		return errors.Trace(err)
	}
	o.Person, o.Ok, err = svc.impl.Load(
		r.Context(),
		i.Key,
	)
	if err != nil {
		return errors.Trace(err)
	}
	w.Header().Set("Content-Type", "application/json")
	err = json.NewEncoder(w).Encode(o)
	if err != nil {
		return errors.Trace(err)
	}
	return nil
}

// doDelete handles marshaling for the Delete function.
func (svc *Intermediate) doDelete(w http.ResponseWriter, r *http.Request) error {
	var i directoryapi.DeleteIn
	var o directoryapi.DeleteOut
	err := httpx.ParseRequestData(r, &i)
	if err!=nil {
		return errors.Trace(err)
	}
	err = svc.impl.Delete(
		r.Context(),
		i.Key,
	)
	if err != nil {
		return errors.Trace(err)
	}
	w.Header().Set("Content-Type", "application/json")
	err = json.NewEncoder(w).Encode(o)
	if err != nil {
		return errors.Trace(err)
	}
	return nil
}

// doUpdate handles marshaling for the Update function.
func (svc *Intermediate) doUpdate(w http.ResponseWriter, r *http.Request) error {
	var i directoryapi.UpdateIn
	var o directoryapi.UpdateOut
	err := httpx.ParseRequestData(r, &i)
	if err!=nil {
		return errors.Trace(err)
	}
	err = svc.impl.Update(
		r.Context(),
		i.Person,
	)
	if err != nil {
		return errors.Trace(err)
	}
	w.Header().Set("Content-Type", "application/json")
	err = json.NewEncoder(w).Encode(o)
	if err != nil {
		return errors.Trace(err)
	}
	return nil
}

// doLoadByEmail handles marshaling for the LoadByEmail function.
func (svc *Intermediate) doLoadByEmail(w http.ResponseWriter, r *http.Request) error {
	var i directoryapi.LoadByEmailIn
	var o directoryapi.LoadByEmailOut
	err := httpx.ParseRequestData(r, &i)
	if err!=nil {
		return errors.Trace(err)
	}
	o.Person, o.Ok, err = svc.impl.LoadByEmail(
		r.Context(),
		i.Email,
	)
	if err != nil {
		return errors.Trace(err)
	}
	w.Header().Set("Content-Type", "application/json")
	err = json.NewEncoder(w).Encode(o)
	if err != nil {
		return errors.Trace(err)
	}
	return nil
}
