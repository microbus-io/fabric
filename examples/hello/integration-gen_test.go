// Code generated by Microbus. DO NOT EDIT.

package hello

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/microbus-io/fabric/application"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/utils"

	"github.com/stretchr/testify/assert"

	"github.com/microbus-io/fabric/examples/hello/helloapi"
)

var (
	_ bytes.Buffer
	_ context.Context
	_ fmt.Stringer
	_ io.Reader
	_ *http.Request
	_ os.File
	_ time.Time
	_ strings.Builder
	_ *httpx.BodyReader
	_ pub.Option
	_ utils.InfiniteChan[int]
	_ assert.TestingT
	_ *helloapi.Client
)

var (
	// App manages the lifecycle of the microservices used in the test.
	App *application.Application
	// Svc is the hello.example microservice being tested.
	Svc *Service
)

func TestMain(m *testing.M) {
	var code int

	// Initialize the application
	err := func() error {
		App = application.NewTesting()
		Svc = NewService().(*Service)
		err := Initialize()
		if err != nil {
			return err
		}
		err = App.Startup()
		if err != nil {
			return err
		}
		return nil
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
		code = 19
	}

	// Run the tests
	if err == nil {
		code = m.Run()
	}

	// Terminate the app
	err = func() error {
		var lastErr error
		err = Terminate()
		if err != nil {
			lastErr = err
		}
		err := App.Shutdown()
		if err != nil {
			lastErr = err
		}
		return lastErr
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
	}

	os.Exit(code)
}

// Context creates a new context for a test.
func Context() context.Context {
	return context.Background()
}

type WebOption func(req *pub.Request) error

// GET sets the method of the request.
func GET() WebOption {
	return WebOption(pub.Method("GET"))
}

// DELETE sets the method of the request.
func DELETE() WebOption {
	return WebOption(pub.Method("DELETE"))
}

// HEAD sets the method of the request.
func HEAD() WebOption {
	return WebOption(pub.Method("HEAD"))
}

// POST sets the method and body of the request.
func POST(body any) WebOption {
	return func(req *pub.Request) error {
		pub.Method("POST")(req)
		return pub.Body(body)(req)
	}
}

// PUT sets the method and body of the request.
func PUT(body any) WebOption {
	return func(req *pub.Request) error {
		pub.Method("PUT")(req)
		return pub.Body(body)(req)
	}
}

// PATCH sets the method and body of the request.
func PATCH(body any) WebOption {
	return func(req *pub.Request) error {
		pub.Method("PATCH")(req)
		return pub.Body(body)(req)
	}
}

// Method sets the method of the request.
func Method(method string) WebOption {
	return WebOption(pub.Method(method))
}

// Header add the header to the request.
// The same header may have multiple values.
func Header(name string, value string) WebOption {
	return WebOption(pub.Header(name, value))
}

// QueryArg adds the query argument to the request.
// The same argument may have multiple values.
func QueryArg(name string, value any) WebOption {
	return WebOption(pub.QueryArg(name, value))
}

// Query adds the escaped query arguments to the request.
// The same argument may have multiple values.
func Query(escapedQueryArgs string) WebOption {
	return WebOption(pub.Query(escapedQueryArgs))
}

// Body sets the body of the request.
// Arguments of type io.Reader, []byte and string are serialized in binary form.
// url.Values is serialized as form data.
// All other types are serialized as JSON.
func Body(body any) WebOption {
	return WebOption(pub.Body(body))
}

// ContentType sets the Content-Type header.
func ContentType(contentType string) WebOption {
	return WebOption(pub.ContentType(contentType))
}

// HelloTestCase assists in asserting against the results of executing Hello.
type HelloTestCase struct {
	res *http.Response
	err error
	
	StatusOK        func(t *testing.T) *HelloTestCase
	StatusCode      func(t *testing.T, statusCode int) *HelloTestCase
	BodyContains    func(t *testing.T, bodyContains any) *HelloTestCase
	BodyNotContains func(t *testing.T, bodyNotContains any) *HelloTestCase
	HeaderContains  func(t *testing.T, headerName string, valueContains string) *HelloTestCase
	Error           func(t *testing.T, errContains string) *HelloTestCase
	NoError         func(t *testing.T) *HelloTestCase
}

// Get returns the result of executing Hello.
func (tc *HelloTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

// Hello executes the web handler and returns a corresponding test case.
func Hello(ctx context.Context, options ...WebOption) *HelloTestCase {
	tc := &HelloTestCase{}
	pubOptions := []pub.Option{
		pub.URL(httpx.JoinHostAndPath("hello.example", `:443/hello`)),
	}
	for _, opt := range options {
		pubOptions = append(pubOptions, pub.Option(opt))
	}
	req, err := pub.NewRequest(pubOptions...)
	if err != nil {
		panic(err)
	}
	httpReq, err := http.NewRequest(req.Method, req.URL, req.Body)
	if err != nil {
		panic(err)
	}
	for name, value := range req.Header {
		httpReq.Header[name] = value
	}
	r := httpReq.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.Hello(w, r)
	})
	tc.res = w.Result()
	tc.StatusOK = func(t *testing.T) *HelloTestCase {
		if assert.NoError(t, tc.err) {
			assert.Equal(t, tc.res.StatusCode, http.StatusOK)
		}
		return tc
	}
	tc.StatusCode = func(t *testing.T, statusCode int) *HelloTestCase {
		if assert.NoError(t, tc.err) {
			assert.Equal(t, tc.res.StatusCode, statusCode)
		}
		return tc
	}
	tc.BodyContains = func(t *testing.T, bodyContains any) *HelloTestCase {
		if assert.NoError(t, tc.err) {
			body := tc.res.Body.(*httpx.BodyReader).Bytes()
			switch v := bodyContains.(type) {
			case []byte:
				assert.True(t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
			case string:
				assert.True(t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
			default:
				vv := fmt.Sprintf("%v", v)
				assert.True(t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
			}
		}
		return tc
	}
	tc.BodyNotContains = func(t *testing.T, bodyNotContains any) *HelloTestCase {
		if assert.NoError(t, tc.err) {
			body := tc.res.Body.(*httpx.BodyReader).Bytes()
			switch v := bodyNotContains.(type) {
			case []byte:
				assert.False(t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
			case string:
				assert.False(t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
			default:
				vv := fmt.Sprintf("%v", v)
				assert.False(t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
			}
		}
		return tc
	}
	tc.HeaderContains = func(t *testing.T, headerName string, valueContains string) *HelloTestCase {
		if assert.NoError(t, tc.err) {
			assert.True(t, strings.Contains(tc.res.Header.Get(headerName), valueContains), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), valueContains)
		}
		return tc
	}
	tc.Error = func(t *testing.T, errContains string) *HelloTestCase {
		if assert.Error(t, tc.err) {
			assert.Contains(t, tc.err.Error(), errContains)
		}
		return tc
	}
	tc.NoError = func(t *testing.T) *HelloTestCase {
		assert.NoError(t, tc.err)
		return tc
	}
	return tc
}

// EchoTestCase assists in asserting against the results of executing Echo.
type EchoTestCase struct {
	res *http.Response
	err error
	
	StatusOK        func(t *testing.T) *EchoTestCase
	StatusCode      func(t *testing.T, statusCode int) *EchoTestCase
	BodyContains    func(t *testing.T, bodyContains any) *EchoTestCase
	BodyNotContains func(t *testing.T, bodyNotContains any) *EchoTestCase
	HeaderContains  func(t *testing.T, headerName string, valueContains string) *EchoTestCase
	Error           func(t *testing.T, errContains string) *EchoTestCase
	NoError         func(t *testing.T) *EchoTestCase
}

// Get returns the result of executing Echo.
func (tc *EchoTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

// Echo executes the web handler and returns a corresponding test case.
func Echo(ctx context.Context, options ...WebOption) *EchoTestCase {
	tc := &EchoTestCase{}
	pubOptions := []pub.Option{
		pub.URL(httpx.JoinHostAndPath("hello.example", `:443/echo`)),
	}
	for _, opt := range options {
		pubOptions = append(pubOptions, pub.Option(opt))
	}
	req, err := pub.NewRequest(pubOptions...)
	if err != nil {
		panic(err)
	}
	httpReq, err := http.NewRequest(req.Method, req.URL, req.Body)
	if err != nil {
		panic(err)
	}
	for name, value := range req.Header {
		httpReq.Header[name] = value
	}
	r := httpReq.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.Echo(w, r)
	})
	tc.res = w.Result()
	tc.StatusOK = func(t *testing.T) *EchoTestCase {
		if assert.NoError(t, tc.err) {
			assert.Equal(t, tc.res.StatusCode, http.StatusOK)
		}
		return tc
	}
	tc.StatusCode = func(t *testing.T, statusCode int) *EchoTestCase {
		if assert.NoError(t, tc.err) {
			assert.Equal(t, tc.res.StatusCode, statusCode)
		}
		return tc
	}
	tc.BodyContains = func(t *testing.T, bodyContains any) *EchoTestCase {
		if assert.NoError(t, tc.err) {
			body := tc.res.Body.(*httpx.BodyReader).Bytes()
			switch v := bodyContains.(type) {
			case []byte:
				assert.True(t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
			case string:
				assert.True(t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
			default:
				vv := fmt.Sprintf("%v", v)
				assert.True(t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
			}
		}
		return tc
	}
	tc.BodyNotContains = func(t *testing.T, bodyNotContains any) *EchoTestCase {
		if assert.NoError(t, tc.err) {
			body := tc.res.Body.(*httpx.BodyReader).Bytes()
			switch v := bodyNotContains.(type) {
			case []byte:
				assert.False(t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
			case string:
				assert.False(t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
			default:
				vv := fmt.Sprintf("%v", v)
				assert.False(t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
			}
		}
		return tc
	}
	tc.HeaderContains = func(t *testing.T, headerName string, valueContains string) *EchoTestCase {
		if assert.NoError(t, tc.err) {
			assert.True(t, strings.Contains(tc.res.Header.Get(headerName), valueContains), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), valueContains)
		}
		return tc
	}
	tc.Error = func(t *testing.T, errContains string) *EchoTestCase {
		if assert.Error(t, tc.err) {
			assert.Contains(t, tc.err.Error(), errContains)
		}
		return tc
	}
	tc.NoError = func(t *testing.T) *EchoTestCase {
		assert.NoError(t, tc.err)
		return tc
	}
	return tc
}

// PingTestCase assists in asserting against the results of executing Ping.
type PingTestCase struct {
	res *http.Response
	err error
	
	StatusOK        func(t *testing.T) *PingTestCase
	StatusCode      func(t *testing.T, statusCode int) *PingTestCase
	BodyContains    func(t *testing.T, bodyContains any) *PingTestCase
	BodyNotContains func(t *testing.T, bodyNotContains any) *PingTestCase
	HeaderContains  func(t *testing.T, headerName string, valueContains string) *PingTestCase
	Error           func(t *testing.T, errContains string) *PingTestCase
	NoError         func(t *testing.T) *PingTestCase
}

// Get returns the result of executing Ping.
func (tc *PingTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

// Ping executes the web handler and returns a corresponding test case.
func Ping(ctx context.Context, options ...WebOption) *PingTestCase {
	tc := &PingTestCase{}
	pubOptions := []pub.Option{
		pub.URL(httpx.JoinHostAndPath("hello.example", `:443/ping`)),
	}
	for _, opt := range options {
		pubOptions = append(pubOptions, pub.Option(opt))
	}
	req, err := pub.NewRequest(pubOptions...)
	if err != nil {
		panic(err)
	}
	httpReq, err := http.NewRequest(req.Method, req.URL, req.Body)
	if err != nil {
		panic(err)
	}
	for name, value := range req.Header {
		httpReq.Header[name] = value
	}
	r := httpReq.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.Ping(w, r)
	})
	tc.res = w.Result()
	tc.StatusOK = func(t *testing.T) *PingTestCase {
		if assert.NoError(t, tc.err) {
			assert.Equal(t, tc.res.StatusCode, http.StatusOK)
		}
		return tc
	}
	tc.StatusCode = func(t *testing.T, statusCode int) *PingTestCase {
		if assert.NoError(t, tc.err) {
			assert.Equal(t, tc.res.StatusCode, statusCode)
		}
		return tc
	}
	tc.BodyContains = func(t *testing.T, bodyContains any) *PingTestCase {
		if assert.NoError(t, tc.err) {
			body := tc.res.Body.(*httpx.BodyReader).Bytes()
			switch v := bodyContains.(type) {
			case []byte:
				assert.True(t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
			case string:
				assert.True(t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
			default:
				vv := fmt.Sprintf("%v", v)
				assert.True(t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
			}
		}
		return tc
	}
	tc.BodyNotContains = func(t *testing.T, bodyNotContains any) *PingTestCase {
		if assert.NoError(t, tc.err) {
			body := tc.res.Body.(*httpx.BodyReader).Bytes()
			switch v := bodyNotContains.(type) {
			case []byte:
				assert.False(t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
			case string:
				assert.False(t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
			default:
				vv := fmt.Sprintf("%v", v)
				assert.False(t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
			}
		}
		return tc
	}
	tc.HeaderContains = func(t *testing.T, headerName string, valueContains string) *PingTestCase {
		if assert.NoError(t, tc.err) {
			assert.True(t, strings.Contains(tc.res.Header.Get(headerName), valueContains), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), valueContains)
		}
		return tc
	}
	tc.Error = func(t *testing.T, errContains string) *PingTestCase {
		if assert.Error(t, tc.err) {
			assert.Contains(t, tc.err.Error(), errContains)
		}
		return tc
	}
	tc.NoError = func(t *testing.T) *PingTestCase {
		assert.NoError(t, tc.err)
		return tc
	}
	return tc
}

// CalculatorTestCase assists in asserting against the results of executing Calculator.
type CalculatorTestCase struct {
	res *http.Response
	err error
	
	StatusOK        func(t *testing.T) *CalculatorTestCase
	StatusCode      func(t *testing.T, statusCode int) *CalculatorTestCase
	BodyContains    func(t *testing.T, bodyContains any) *CalculatorTestCase
	BodyNotContains func(t *testing.T, bodyNotContains any) *CalculatorTestCase
	HeaderContains  func(t *testing.T, headerName string, valueContains string) *CalculatorTestCase
	Error           func(t *testing.T, errContains string) *CalculatorTestCase
	NoError         func(t *testing.T) *CalculatorTestCase
}

// Get returns the result of executing Calculator.
func (tc *CalculatorTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

// Calculator executes the web handler and returns a corresponding test case.
func Calculator(ctx context.Context, options ...WebOption) *CalculatorTestCase {
	tc := &CalculatorTestCase{}
	pubOptions := []pub.Option{
		pub.URL(httpx.JoinHostAndPath("hello.example", `:443/calculator`)),
	}
	for _, opt := range options {
		pubOptions = append(pubOptions, pub.Option(opt))
	}
	req, err := pub.NewRequest(pubOptions...)
	if err != nil {
		panic(err)
	}
	httpReq, err := http.NewRequest(req.Method, req.URL, req.Body)
	if err != nil {
		panic(err)
	}
	for name, value := range req.Header {
		httpReq.Header[name] = value
	}
	r := httpReq.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.Calculator(w, r)
	})
	tc.res = w.Result()
	tc.StatusOK = func(t *testing.T) *CalculatorTestCase {
		if assert.NoError(t, tc.err) {
			assert.Equal(t, tc.res.StatusCode, http.StatusOK)
		}
		return tc
	}
	tc.StatusCode = func(t *testing.T, statusCode int) *CalculatorTestCase {
		if assert.NoError(t, tc.err) {
			assert.Equal(t, tc.res.StatusCode, statusCode)
		}
		return tc
	}
	tc.BodyContains = func(t *testing.T, bodyContains any) *CalculatorTestCase {
		if assert.NoError(t, tc.err) {
			body := tc.res.Body.(*httpx.BodyReader).Bytes()
			switch v := bodyContains.(type) {
			case []byte:
				assert.True(t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
			case string:
				assert.True(t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
			default:
				vv := fmt.Sprintf("%v", v)
				assert.True(t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
			}
		}
		return tc
	}
	tc.BodyNotContains = func(t *testing.T, bodyNotContains any) *CalculatorTestCase {
		if assert.NoError(t, tc.err) {
			body := tc.res.Body.(*httpx.BodyReader).Bytes()
			switch v := bodyNotContains.(type) {
			case []byte:
				assert.False(t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
			case string:
				assert.False(t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
			default:
				vv := fmt.Sprintf("%v", v)
				assert.False(t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
			}
		}
		return tc
	}
	tc.HeaderContains = func(t *testing.T, headerName string, valueContains string) *CalculatorTestCase {
		if assert.NoError(t, tc.err) {
			assert.True(t, strings.Contains(tc.res.Header.Get(headerName), valueContains), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), valueContains)
		}
		return tc
	}
	tc.Error = func(t *testing.T, errContains string) *CalculatorTestCase {
		if assert.Error(t, tc.err) {
			assert.Contains(t, tc.err.Error(), errContains)
		}
		return tc
	}
	tc.NoError = func(t *testing.T) *CalculatorTestCase {
		assert.NoError(t, tc.err)
		return tc
	}
	return tc
}

// BusJPEGTestCase assists in asserting against the results of executing BusJPEG.
type BusJPEGTestCase struct {
	res *http.Response
	err error
	
	StatusOK        func(t *testing.T) *BusJPEGTestCase
	StatusCode      func(t *testing.T, statusCode int) *BusJPEGTestCase
	BodyContains    func(t *testing.T, bodyContains any) *BusJPEGTestCase
	BodyNotContains func(t *testing.T, bodyNotContains any) *BusJPEGTestCase
	HeaderContains  func(t *testing.T, headerName string, valueContains string) *BusJPEGTestCase
	Error           func(t *testing.T, errContains string) *BusJPEGTestCase
	NoError         func(t *testing.T) *BusJPEGTestCase
}

// Get returns the result of executing BusJPEG.
func (tc *BusJPEGTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

// BusJPEG executes the web handler and returns a corresponding test case.
func BusJPEG(ctx context.Context, options ...WebOption) *BusJPEGTestCase {
	tc := &BusJPEGTestCase{}
	pubOptions := []pub.Option{
		pub.URL(httpx.JoinHostAndPath("hello.example", `:443/bus.jpeg`)),
	}
	for _, opt := range options {
		pubOptions = append(pubOptions, pub.Option(opt))
	}
	req, err := pub.NewRequest(pubOptions...)
	if err != nil {
		panic(err)
	}
	httpReq, err := http.NewRequest(req.Method, req.URL, req.Body)
	if err != nil {
		panic(err)
	}
	for name, value := range req.Header {
		httpReq.Header[name] = value
	}
	r := httpReq.WithContext(ctx)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.BusJPEG(w, r)
	})
	tc.res = w.Result()
	tc.StatusOK = func(t *testing.T) *BusJPEGTestCase {
		if assert.NoError(t, tc.err) {
			assert.Equal(t, tc.res.StatusCode, http.StatusOK)
		}
		return tc
	}
	tc.StatusCode = func(t *testing.T, statusCode int) *BusJPEGTestCase {
		if assert.NoError(t, tc.err) {
			assert.Equal(t, tc.res.StatusCode, statusCode)
		}
		return tc
	}
	tc.BodyContains = func(t *testing.T, bodyContains any) *BusJPEGTestCase {
		if assert.NoError(t, tc.err) {
			body := tc.res.Body.(*httpx.BodyReader).Bytes()
			switch v := bodyContains.(type) {
			case []byte:
				assert.True(t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
			case string:
				assert.True(t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
			default:
				vv := fmt.Sprintf("%v", v)
				assert.True(t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
			}
		}
		return tc
	}
	tc.BodyNotContains = func(t *testing.T, bodyNotContains any) *BusJPEGTestCase {
		if assert.NoError(t, tc.err) {
			body := tc.res.Body.(*httpx.BodyReader).Bytes()
			switch v := bodyNotContains.(type) {
			case []byte:
				assert.False(t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
			case string:
				assert.False(t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
			default:
				vv := fmt.Sprintf("%v", v)
				assert.False(t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
			}
		}
		return tc
	}
	tc.HeaderContains = func(t *testing.T, headerName string, valueContains string) *BusJPEGTestCase {
		if assert.NoError(t, tc.err) {
			assert.True(t, strings.Contains(tc.res.Header.Get(headerName), valueContains), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), valueContains)
		}
		return tc
	}
	tc.Error = func(t *testing.T, errContains string) *BusJPEGTestCase {
		if assert.Error(t, tc.err) {
			assert.Contains(t, tc.err.Error(), errContains)
		}
		return tc
	}
	tc.NoError = func(t *testing.T) *BusJPEGTestCase {
		assert.NoError(t, tc.err)
		return tc
	}
	return tc
}

// TickTockTestCase assists in asserting against the results of executing TickTock.
type TickTockTestCase struct {
	err error

	Error   func(t *testing.T, errContains string) *TickTockTestCase
	NoError func(t *testing.T) *TickTockTestCase
}

// Get returns the result of executing TickTock.
func (tc *TickTockTestCase) Get() (err error) {
	return tc.err
}

// TickTock executes the ticker and returns a corresponding test case.
func TickTock(ctx context.Context) *TickTockTestCase {
	tc := &TickTockTestCase{}
	tc.err = utils.CatchPanic(func () error {
		return Svc.TickTock(ctx)
	})
	tc.Error = func(t *testing.T, errContains string) *TickTockTestCase {
		if assert.Error(t, tc.err) {
			assert.Contains(t, tc.err.Error(), errContains)
		}
		return tc
	}
	tc.NoError = func(t *testing.T) *TickTockTestCase {
		assert.NoError(t, tc.err)
		return tc
	}
	return tc
}
