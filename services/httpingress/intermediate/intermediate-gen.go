/*
Copyright 2023 Microbus LLC and various contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Microbus. DO NOT EDIT.

/*
Package intermediate serves as the foundation of the http.ingress.sys microservice.

The HTTP Ingress microservice relays incoming HTTP requests to the NATS bus.
*/
package intermediate

import (
	"context"
	"embed"
	"encoding/json"
	"fmt"
	"net/http"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/microbus-io/fabric/cb"
	"github.com/microbus-io/fabric/cfg"
	"github.com/microbus-io/fabric/connector"
	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/log"
	"github.com/microbus-io/fabric/shardedsql"
	"github.com/microbus-io/fabric/sub"
	"github.com/microbus-io/fabric/utils"

	"github.com/microbus-io/fabric/services/httpingress/resources"
	"github.com/microbus-io/fabric/services/httpingress/httpingressapi"
)

var (
	_ context.Context
	_ *embed.FS
	_ *json.Decoder
	_ fmt.Stringer
	_ *http.Request
	_ filepath.WalkFunc
	_ strconv.NumError
	_ strings.Reader
	_ time.Duration
	_ cb.Option
	_ cfg.Option
	_ *errors.TracedError
	_ *httpx.ResponseRecorder
	_ *log.Field
	_ *shardedsql.DB
	_ sub.Option
	_ httpingressapi.Client
)

// ToDo defines the interface that the microservice must implement.
// The intermediate delegates handling to this interface.
type ToDo interface {
	OnStartup(ctx context.Context) (err error)
	OnShutdown(ctx context.Context) (err error)
	OnChangedPorts(ctx context.Context) (err error)
	OnChangedAllowedOrigins(ctx context.Context) (err error)
	OnChangedPortMappings(ctx context.Context) (err error)
	OnChangedReadTimeout(ctx context.Context) (err error)
	OnChangedWriteTimeout(ctx context.Context) (err error)
	OnChangedReadHeaderTimeout(ctx context.Context) (err error)
}

// Intermediate extends and customizes the generic base connector.
// Code generated microservices then extend the intermediate.
type Intermediate struct {
	*connector.Connector
	impl ToDo
}

// NewService creates a new intermediate service.
func NewService(impl ToDo, version int) *Intermediate {
	svc := &Intermediate{
		Connector: connector.New("http.ingress.sys"),
		impl: impl,
	}
	svc.SetVersion(version)
	svc.SetDescription(`The HTTP Ingress microservice relays incoming HTTP requests to the NATS bus.`)

	// Lifecycle
	svc.SetOnStartup(svc.impl.OnStartup)
	svc.SetOnShutdown(svc.impl.OnShutdown)

	// Configs
	svc.SetOnConfigChanged(svc.doOnConfigChanged)
	svc.DefineConfig(
		"TimeBudget",
		cfg.Description(`TimeBudget specifies the timeout for handling a request, after it has been read.`),
		cfg.Validation(`dur [1s,]`),
		cfg.DefaultValue(`20s`),
	)
	svc.DefineConfig(
		"Ports",
		cfg.Description(`Ports is a comma-separated list of HTTP ports on which to listen for requests.`),
		cfg.DefaultValue(`8080`),
	)
	svc.DefineConfig(
		"RequestMemoryLimit",
		cfg.Description(`RequestMemoryLimit is the memory capacity used to hold pending requests, in megabytes.`),
		cfg.Validation(`int [1,]`),
		cfg.DefaultValue(`4096`),
	)
	svc.DefineConfig(
		"AllowedOrigins",
		cfg.Description(`AllowedOrigins is a comma-separated list of CORS origins to allow requests from.
The * origin can be used to allow CORS request from all origins.`),
		cfg.DefaultValue(`*`),
	)
	svc.DefineConfig(
		"PortMappings",
		cfg.Description(`PortMappings is a comma-separated list of mappings in the form x:y->z where x is the inbound
HTTP port, y is the requested NATS port, and z is the port to serve.
An HTTP request https://ingresshost:x/servicehost:y/path is mapped to internal NATS
request https://servicehost:z/path .
Both x and y can be * to indicate all ports. Setting z to * indicates to serve the requested
port y without change. Specific rules take precedence over * rules.
The default mapping grants access to all internal ports via HTTP port 8080 but restricts
HTTP ports 443 and 80 to only internal port 443.`),
		cfg.DefaultValue(`8080:*->*, 443:*->443, 80:*->443`),
	)
	svc.DefineConfig(
		"ReadTimeout",
		cfg.Description(`ReadTimeout specifies the timeout for fully reading a request.`),
		cfg.Validation(`dur [1s,]`),
		cfg.DefaultValue(`5m`),
	)
	svc.DefineConfig(
		"WriteTimeout",
		cfg.Description(`WriteTimeout specifies the timeout for fully writing the response to a request.`),
		cfg.Validation(`dur [1s,]`),
		cfg.DefaultValue(`5m`),
	)
	svc.DefineConfig(
		"ReadHeaderTimeout",
		cfg.Description(`ReadHeaderTimeout specifies the timeout for fully reading the header of a request.`),
		cfg.Validation(`dur [1s,]`),
		cfg.DefaultValue(`20s`),
	)
	svc.DefineConfig(
		"Middleware",
		cfg.Description(`Middleware defines a microservice to delegate all requests to.
The URL of the middleware must be fully qualified, for example,
"https://middle.ware/serve" or "https://middle.ware:123".`),
	)

	return svc
}

// Resources is the in-memory file system of the embedded resources.
func (svc *Intermediate) Resources() utils.ResourceLoader {
	return utils.ResourceLoader{FS: resources.FS}
}

// doOnConfigChanged is called when the config of the microservice changes.
func (svc *Intermediate) doOnConfigChanged(ctx context.Context, changed func(string) bool) (err error) {
	if changed("Ports") {
		err := svc.impl.OnChangedPorts(ctx)
		if err != nil {
			return errors.Trace(err)
		}
	}
	if changed("AllowedOrigins") {
		err := svc.impl.OnChangedAllowedOrigins(ctx)
		if err != nil {
			return errors.Trace(err)
		}
	}
	if changed("PortMappings") {
		err := svc.impl.OnChangedPortMappings(ctx)
		if err != nil {
			return errors.Trace(err)
		}
	}
	if changed("ReadTimeout") {
		err := svc.impl.OnChangedReadTimeout(ctx)
		if err != nil {
			return errors.Trace(err)
		}
	}
	if changed("WriteTimeout") {
		err := svc.impl.OnChangedWriteTimeout(ctx)
		if err != nil {
			return errors.Trace(err)
		}
	}
	if changed("ReadHeaderTimeout") {
		err := svc.impl.OnChangedReadHeaderTimeout(ctx)
		if err != nil {
			return errors.Trace(err)
		}
	}
	return nil
}

/*
TimeBudget specifies the timeout for handling a request, after it has been read.
*/
func (svc *Intermediate) TimeBudget() (budget time.Duration) {
	_val := svc.Config("TimeBudget")
	_dur, _ := time.ParseDuration(_val)
	return _dur
}

/*
TimeBudget specifies the timeout for handling a request, after it has been read.
*/
func TimeBudget(budget time.Duration) (func(connector.Service) error) {
	return func(svc connector.Service) error {
		return svc.SetConfig("TimeBudget", fmt.Sprintf("%v", budget))
	}
}

/*
Ports is a comma-separated list of HTTP ports on which to listen for requests.
*/
func (svc *Intermediate) Ports() (port string) {
	_val := svc.Config("Ports")
	return _val
}

/*
Ports is a comma-separated list of HTTP ports on which to listen for requests.
*/
func Ports(port string) (func(connector.Service) error) {
	return func(svc connector.Service) error {
		return svc.SetConfig("Ports", fmt.Sprintf("%v", port))
	}
}

/*
RequestMemoryLimit is the memory capacity used to hold pending requests, in megabytes.
*/
func (svc *Intermediate) RequestMemoryLimit() (megaBytes int) {
	_val := svc.Config("RequestMemoryLimit")
	_i, _ := strconv.ParseInt(_val, 10, 64)
	return int(_i)
}

/*
RequestMemoryLimit is the memory capacity used to hold pending requests, in megabytes.
*/
func RequestMemoryLimit(megaBytes int) (func(connector.Service) error) {
	return func(svc connector.Service) error {
		return svc.SetConfig("RequestMemoryLimit", fmt.Sprintf("%v", megaBytes))
	}
}

/*
AllowedOrigins is a comma-separated list of CORS origins to allow requests from.
The * origin can be used to allow CORS request from all origins.
*/
func (svc *Intermediate) AllowedOrigins() (origins string) {
	_val := svc.Config("AllowedOrigins")
	return _val
}

/*
AllowedOrigins is a comma-separated list of CORS origins to allow requests from.
The * origin can be used to allow CORS request from all origins.
*/
func AllowedOrigins(origins string) (func(connector.Service) error) {
	return func(svc connector.Service) error {
		return svc.SetConfig("AllowedOrigins", fmt.Sprintf("%v", origins))
	}
}

/*
PortMappings is a comma-separated list of mappings in the form x:y->z where x is the inbound
HTTP port, y is the requested NATS port, and z is the port to serve.
An HTTP request https://ingresshost:x/servicehost:y/path is mapped to internal NATS
request https://servicehost:z/path .
Both x and y can be * to indicate all ports. Setting z to * indicates to serve the requested
port y without change. Specific rules take precedence over * rules.
The default mapping grants access to all internal ports via HTTP port 8080 but restricts
HTTP ports 443 and 80 to only internal port 443.
*/
func (svc *Intermediate) PortMappings() (mappings string) {
	_val := svc.Config("PortMappings")
	return _val
}

/*
PortMappings is a comma-separated list of mappings in the form x:y->z where x is the inbound
HTTP port, y is the requested NATS port, and z is the port to serve.
An HTTP request https://ingresshost:x/servicehost:y/path is mapped to internal NATS
request https://servicehost:z/path .
Both x and y can be * to indicate all ports. Setting z to * indicates to serve the requested
port y without change. Specific rules take precedence over * rules.
The default mapping grants access to all internal ports via HTTP port 8080 but restricts
HTTP ports 443 and 80 to only internal port 443.
*/
func PortMappings(mappings string) (func(connector.Service) error) {
	return func(svc connector.Service) error {
		return svc.SetConfig("PortMappings", fmt.Sprintf("%v", mappings))
	}
}

/*
ReadTimeout specifies the timeout for fully reading a request.
*/
func (svc *Intermediate) ReadTimeout() (timeout time.Duration) {
	_val := svc.Config("ReadTimeout")
	_dur, _ := time.ParseDuration(_val)
	return _dur
}

/*
ReadTimeout specifies the timeout for fully reading a request.
*/
func ReadTimeout(timeout time.Duration) (func(connector.Service) error) {
	return func(svc connector.Service) error {
		return svc.SetConfig("ReadTimeout", fmt.Sprintf("%v", timeout))
	}
}

/*
WriteTimeout specifies the timeout for fully writing the response to a request.
*/
func (svc *Intermediate) WriteTimeout() (timeout time.Duration) {
	_val := svc.Config("WriteTimeout")
	_dur, _ := time.ParseDuration(_val)
	return _dur
}

/*
WriteTimeout specifies the timeout for fully writing the response to a request.
*/
func WriteTimeout(timeout time.Duration) (func(connector.Service) error) {
	return func(svc connector.Service) error {
		return svc.SetConfig("WriteTimeout", fmt.Sprintf("%v", timeout))
	}
}

/*
ReadHeaderTimeout specifies the timeout for fully reading the header of a request.
*/
func (svc *Intermediate) ReadHeaderTimeout() (timeout time.Duration) {
	_val := svc.Config("ReadHeaderTimeout")
	_dur, _ := time.ParseDuration(_val)
	return _dur
}

/*
ReadHeaderTimeout specifies the timeout for fully reading the header of a request.
*/
func ReadHeaderTimeout(timeout time.Duration) (func(connector.Service) error) {
	return func(svc connector.Service) error {
		return svc.SetConfig("ReadHeaderTimeout", fmt.Sprintf("%v", timeout))
	}
}

/*
Middleware defines a microservice to delegate all requests to.
The URL of the middleware must be fully qualified, for example,
"https://middle.ware/serve" or "https://middle.ware:123".
*/
func (svc *Intermediate) Middleware() (viaURL string) {
	_val := svc.Config("Middleware")
	return _val
}

/*
Middleware defines a microservice to delegate all requests to.
The URL of the middleware must be fully qualified, for example,
"https://middle.ware/serve" or "https://middle.ware:123".
*/
func Middleware(viaURL string) (func(connector.Service) error) {
	return func(svc connector.Service) error {
		return svc.SetConfig("Middleware", fmt.Sprintf("%v", viaURL))
	}
}
