// Code generated by Microbus. DO NOT EDIT.

package configuratorapi

import (
	"context"
	"encoding/json"
	"net/http"
	"strings"
	"time"

	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/pub"
)

var (
	_ context.Context
    _ json.Decoder
	_ http.Request
	_ strings.Reader
	_ time.Duration

	_ errors.TracedError
	_ pub.Request
)

const ServiceName = "configurator.sys"

// Service is an interface abstraction of a microservice used by the client.
// The connector implements this interface.
type Service interface {
	Request(ctx context.Context, options ...pub.Option) (*http.Response, error)
	Publish(ctx context.Context, options ...pub.Option) <-chan *pub.Response
}

// Client provides type-safe access to the endpoints of the "configurator.sys" microservice.
// This simple version is for unicast calls.
type Client struct {
	svc  Service
	host string
}

// NewClient creates a new unicast client to the "configurator.sys" microservice.
func NewClient(caller Service) *Client {
	return &Client{
		svc:  caller,
		host: "configurator.sys",
	}
}

// ForHost replaces the default host name of this client.
func (_c *Client) ForHost(host string) *Client {
	_c.host = host
	return _c
}

// MulticastClient provides type-safe access to the endpoints of the "configurator.sys" microservice.
// This advanced version is for multicast calls.
type MulticastClient struct {
	svc  Service
	host string
}

// NewMulticastClient creates a new multicast client to the "configurator.sys" microservice.
func NewMulticastClient(caller Service) *MulticastClient {
	return &MulticastClient{
		svc:  caller,
		host: "configurator.sys",
	}
}

// ForHost replaces the default host name of this client.
func (_c *MulticastClient) ForHost(host string) *MulticastClient {
	_c.host = host
	return _c
}

// ValuesIn are the incoming arguments to Values.
type ValuesIn struct {
	Names []string `json:"names"`
}

// ValuesOut are the return values of Values.
type ValuesOut struct {
	data struct {
		Values map[string]string `json:"values"`
	}
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *ValuesOut) Get() (values map[string]string, err error) {
	values = _out.data.Values
	err = _out.err
	return
}

/*
Values returns the values associated with the specified config property names for the caller microservice.
*/
func (_c *Client) Values(ctx context.Context, names []string) (values map[string]string, err error) {
	_in := ValuesIn{
		names,
	}
	_body, _err := json.Marshal(_in)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}

	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method("POST"),
		pub.URL(joinHostAndPath(_c.host, `/values`)),
		pub.Body(_body),
		pub.Header("Content-Type", "application/json"),
	)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	var _out ValuesOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&(_out.data))
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	values = _out.data.Values
	return
}

/*
Values returns the values associated with the specified config property names for the caller microservice.
*/
func (_c *MulticastClient) Values(ctx context.Context, names []string, _options ...pub.Option) <-chan *ValuesOut {
	_in := ValuesIn{
		names,
	}
	_body, _err := json.Marshal(_in)
	if _err != nil {
		_res := make(chan *ValuesOut, 1)
		_res <- &ValuesOut{err: errors.Trace(_err)}
		close(_res)
		return _res
	}

	_opts := []pub.Option{
		pub.Method("POST"),
		pub.URL(joinHostAndPath(_c.host, `/values`)),
		pub.Body(_body),
		pub.Header("Content-Type", "application/json"),
	}
	_opts = append(_opts, _options...)
	_ch := _c.svc.Publish(ctx, _opts...)

	_res := make(chan *ValuesOut, cap(_ch))
	go func() {
		for _i := range _ch {
			var _r ValuesOut
			_httpRes, _err := _i.Get()
			_r.HTTPResponse = _httpRes
			if _err != nil {
				_r.err = errors.Trace(_err)
			} else {
				_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
				if _err != nil {
					_r.err = errors.Trace(_err)
				}
			}
			_res <- &_r
		}
		close(_res)
	}()
	return _res
}

// RefreshIn are the incoming arguments to Refresh.
type RefreshIn struct {
}

// RefreshOut are the return values of Refresh.
type RefreshOut struct {
	data struct {
	}
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *RefreshOut) Get() (err error) {
	err = _out.err
	return
}

/*
Refresh tells all microservices to contact the configurator and refresh their configs.
An error is returned if any of the values sent to the microservices fails validation.
*/
func (_c *Client) Refresh(ctx context.Context) (err error) {
	_in := RefreshIn{
	}
	_body, _err := json.Marshal(_in)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}

	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method("POST"),
		pub.URL(joinHostAndPath(_c.host, `/refresh`)),
		pub.Body(_body),
		pub.Header("Content-Type", "application/json"),
	)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	var _out RefreshOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&(_out.data))
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	return
}

/*
Refresh tells all microservices to contact the configurator and refresh their configs.
An error is returned if any of the values sent to the microservices fails validation.
*/
func (_c *MulticastClient) Refresh(ctx context.Context, _options ...pub.Option) <-chan *RefreshOut {
	_in := RefreshIn{
	}
	_body, _err := json.Marshal(_in)
	if _err != nil {
		_res := make(chan *RefreshOut, 1)
		_res <- &RefreshOut{err: errors.Trace(_err)}
		close(_res)
		return _res
	}

	_opts := []pub.Option{
		pub.Method("POST"),
		pub.URL(joinHostAndPath(_c.host, `/refresh`)),
		pub.Body(_body),
		pub.Header("Content-Type", "application/json"),
	}
	_opts = append(_opts, _options...)
	_ch := _c.svc.Publish(ctx, _opts...)

	_res := make(chan *RefreshOut, cap(_ch))
	go func() {
		for _i := range _ch {
			var _r RefreshOut
			_httpRes, _err := _i.Get()
			_r.HTTPResponse = _httpRes
			if _err != nil {
				_r.err = errors.Trace(_err)
			} else {
				_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
				if _err != nil {
					_r.err = errors.Trace(_err)
				}
			}
			_res <- &_r
		}
		close(_res)
	}()
	return _res
}

// SyncIn are the incoming arguments to Sync.
type SyncIn struct {
	Timestamp time.Time `json:"timestamp"`
	Values map[string]map[string]string `json:"values"`
}

// SyncOut are the return values of Sync.
type SyncOut struct {
	data struct {
	}
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *SyncOut) Get() (err error) {
	err = _out.err
	return
}

/*
Sync is used to synchronize values among replica peers of the configurator.
*/
func (_c *Client) Sync(ctx context.Context, timestamp time.Time, values map[string]map[string]string) (err error) {
	_in := SyncIn{
		timestamp,
		values,
	}
	_body, _err := json.Marshal(_in)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}

	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method("POST"),
		pub.URL(joinHostAndPath(_c.host, `/sync`)),
		pub.Body(_body),
		pub.Header("Content-Type", "application/json"),
	)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	var _out SyncOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&(_out.data))
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	return
}

/*
Sync is used to synchronize values among replica peers of the configurator.
*/
func (_c *MulticastClient) Sync(ctx context.Context, timestamp time.Time, values map[string]map[string]string, _options ...pub.Option) <-chan *SyncOut {
	_in := SyncIn{
		timestamp,
		values,
	}
	_body, _err := json.Marshal(_in)
	if _err != nil {
		_res := make(chan *SyncOut, 1)
		_res <- &SyncOut{err: errors.Trace(_err)}
		close(_res)
		return _res
	}

	_opts := []pub.Option{
		pub.Method("POST"),
		pub.URL(joinHostAndPath(_c.host, `/sync`)),
		pub.Body(_body),
		pub.Header("Content-Type", "application/json"),
	}
	_opts = append(_opts, _options...)
	_ch := _c.svc.Publish(ctx, _opts...)

	_res := make(chan *SyncOut, cap(_ch))
	go func() {
		for _i := range _ch {
			var _r SyncOut
			_httpRes, _err := _i.Get()
			_r.HTTPResponse = _httpRes
			if _err != nil {
				_r.err = errors.Trace(_err)
			} else {
				_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
				if _err != nil {
					_r.err = errors.Trace(_err)
				}
			}
			_res <- &_r
		}
		close(_res)
	}()
	return _res
}

// joinHostAndPath combines the host name and the partial path.
func joinHostAndPath(hostName string, path string) string {
	if path == "" {
		// (empty)
		return "https://" + hostName + ":443"
	}
	if strings.HasPrefix(path, ":") {
		// :1080/path
		return "https://" + hostName + path
	}
	if strings.HasPrefix(path, "/") {
		// /path/with/slash
		return "https://" + hostName + ":443" + path
	}
	if !strings.Contains(path, "://") {
		// path/with/no/slash
		return "https://" + hostName + ":443/" + path
	}
	return path
}
